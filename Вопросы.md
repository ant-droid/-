#### 1. Назовите основные функции СУБД

Современные системы управления базами данных выполняют семь ключевых функций:

1. Управление данными
   - Организация хранения (таблицы, индексы, кластеры)
   - Оптимизация физического размещения
   - Кэширование часто используемых данных

2. Языковые средства
   - Поддержка SQL (DDL, DML, DCL)
   - Парсинг и оптимизация запросов
   - Подготовленные выражения

3. Транзакционный менеджмент
   - ACID-гарантии
   - Управление блокировками
   - Контроль уровней изоляции

4. Целостность данных
   - Первичные и внешние ключи
   - Проверочные ограничения (CHECK)
   - Триггеры и правила

5. Безопасность
   - Иерархия прав доступа
   - Шифрование данных
   - Аудит действий

6. Восстановление
   - Журнал транзакций (WAL)
   - Точки восстановления
   - Репликация

7. Администрирование
   - Мониторинг производительности
   - Настройка параметров
   - Резервное копирование

---

#### 2. Примеры СУБД

Реляционные (SQL):
1. Коммерческие:
   - Oracle Database (промышленные решения)
   - Microsoft SQL Server (интеграция с .NET)
   - IBM DB2 (мейнфреймы)

2. Открытые:
   - PostgreSQL (расширяемая СУБД)
   - MySQL/MariaDB (веб-приложения)
   - SQLite (встраиваемая)

Нереляционные (NoSQL):
1. Документные:
   - MongoDB (JSON-документы)
   - CouchDB (синхронизация)

2. Ключ-значение:
   - Redis (оперативная память)
   - DynamoDB (AWS)

3. Колоночные:
   - Cassandra (распределённая)
   - Bigtable (Google)

4. Графовые:
   - Neo4j (сетевые структуры)
   - ArangoDB (мультимодельная)

---

#### 3. Что такое ядро СУБД?

Ядро - центральный исполняемый модуль СУБД, включающий:

1. Процессор запросов:
   - Лексический анализ SQL
   - Генерация планов выполнения
   - Оптимизатор (cost-based)

2. Менеджер транзакций:
   - Расписание транзакций
   - Управление блокировками
   - Контроль deadlock'ов

3. Буферный пул:
   - Кэширование страниц
   - Алгоритмы вытеснения (LRU)
   - Контроль согласованности

4. Менеджер хранения:
   - Организация файлов данных
   - Управление пространством
   - Работа с индексами (B-деревья)


---

#### 4. Перечислите компоненты СУБД

1. Ядро СУБД (как описано выше)
2. Подсистема хранения:
   - Файлы данных (.mdf, .ibd)
   - Журнал транзакций (.ldf)
   - Контрольные точки

3. Сетевые компоненты:
   - Протоколы (TCP/IP, Named Pipes)
   - Пул соединений
   - Шифрование трафика

4. Инструменты администрирования:
   - Консоль управления
   - Профилировщик запросов
   - Мастер настройки

5. Вспомогательные модули:
   - Full-text search
   - Геопространственные расширения
   - OLAP-обработчик

6. API-интерфейсы:
   - ODBC/JDBC-драйверы
   - OLE DB провайдеры
   - Специфичные протоколы (MongoDB Wire)

---

#### 5. Что такое транзакция?

Формальное определение:
Последовательность операций, удовлетворяющая ACID-свойствам.

Жизненный цикл:
1. BEGIN → 2. Выполнение → 3. COMMIT/ROLLBACK

Уровни изоляции:
1. Read Uncommitted (грязное чтение)
2. Read Committed (Oracle по умолчанию)
3. Repeatable Read (MySQL InnoDB)
4. Serializable (строгая изоляция)

Пример банковской транзакции:
START TRANSACTION;
  UPDATE accounts SET balance = balance - 100 WHERE id = 1;
  UPDATE accounts SET balance = balance + 100 WHERE id = 2;
  -- Проверка ошибок
  IF @@ERROR = 0 THEN COMMIT;
  ELSE ROLLBACK;
END
Особенности реализации:
- В Oracle - неявное начало транзакции
- В SQL Server - явные точки сохранения (SAVEPOINT)
- В MySQL - поддержка в движках InnoDB, но не MyISAM

---

### 6. Опишите назначение журнализации

Журнализация (транзакционный лог) — это механизм записи всех изменений БД перед их фактическим применением. Реализуется через Write-Ahead Logging (WAL).

#### Ключевые задачи:
1. Гарантия долговечности (Durability)  
   - Изменения сначала записываются в журнал, затем в БД  
   - При сбое система восстанавливается по журналу

2. Поддержка отката транзакций (UNDO)  
   - Хранение "достаронных" значений для ROLLBACK  
   - Пример:  
    
     BEGIN;
     UPDATE accounts SET balance = balance - 100;  -- Запись в журнал: "balance было 500"
     ROLLBACK;  -- Восстановление из журнала
     
3. Повтор выполненных операций (REDO)  
   - После сбоя повторяются зафиксированные, но не записанные на диск изменения

4. Аудит и репликация  
   - Логи используются для:  
     - Отслеживания изменений (кто, когда, что изменил)  
     - Синхронизации реплик (MySQL binlog, PostgreSQL WAL)

#### Технические детали:
- Циклическая перезапись: журналы ротируются для экономии пространства
- Групповая фиксация: несколько изменений записываются вместе для производительности
- Форматы журналов:  
  - Физический (изменения байтов)  
  - Логический (SQL-операции)

---

### 7. Что такое первичный ключ отношения?

Первичный ключ (Primary Key, PK) — минимальный набор атрибутов, однозначно идентифицирующий строку в таблице.

#### Характеристики:
| Свойство          | Описание                                                                 |
|-------------------|--------------------------------------------------------------------------|
| Уникальность  | Нет двух строк с одинаковым PK                                           |
| Неизменность  | Значение PK не должно модифицироваться (нарушает ссылочную целостность) |
| Отсутствие NULL | Все столбцы PK обязаны иметь значения                                   |

#### Типы PK:
1. Естественный ключ  
   - Основан на бизнес-данных: паспортный номер, ISBN книги  
   - Проблема: может измениться (например, смена паспорта)

2. Суррогатный ключ  
   - Искусственный идентификатор:  
     - Автоинкремент (INT IDENTITY)  
     - UUID/GUID  
     - Sequence (Oracle, PostgreSQL)

#### Примеры:
-- Суррогатный ключ
CREATE TABLE users (
    user_id BIGSERIAL PRIMARY KEY,  -- Автоинкремент
    email VARCHAR(255) UNIQUE
);

-- Составной естественный ключ
CREATE TABLE enrollment (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id)  -- Составной PK
);
#### Важность PK:
- Основа для связей через FOREIGN KEY  
- Автоматическое создание кластерного индекса (в большинстве СУБД)  
- Обеспечение производительности запросов  

---

### 8. Отличие реляционной модели от нереляционной

#### Реляционные СУБД (SQL):
- Структура: Таблицы с жесткой схемой (строки, столбцы)  
- Связи: Через внешние ключи (JOIN-операции)  
- Примеры: MySQL, PostgreSQL, Oracle  
- Преимущества:  
  - ACID-транзакции  
  - Сложные запросы (GROUP BY, подзапросы)  
- Недостатки:  
  - Плохая горизонтальная масштабируемость  

#### Нереляционные СУБД (NoSQL):
- Основные типы:  
  | Тип                | Примеры         | Использование               |
  |--------------------|-----------------|-----------------------------|
  | Документные        | MongoDB         | JSON-данные                 |
  | Ключ-значение      | Redis           | Кэширование                 |
  | Колоночные         | Cassandra       | Аналитика                   |
  | Графовые           | Neo4j           | Социальные сети             |

- Преимущества:  
  - Гибкость схемы  
  - Горизонтальное масштабирование  
  - Высокая производительность для специфичных задач  
- Недостатки:  
  - Ограниченная поддержка транзакций  
  - Сложные аналитические запросы  

---

### 9. Для чего используется внешний ключ в таблице?

Внешний ключ (Foreign Key, FK) — ограничение, связывающее данные между таблицами.

#### Основные функции:
1. Реализация связей  
   - Один-ко-многим:  
    
     CREATE TABLE orders (
         order_id INT PRIMARY KEY,
         customer_id INT REFERENCES customers(customer_id)
     );
     
   - Один-к-одному (через UNIQUE + FK)

2. Поддержание ссылочной целостности  
   - Запрещает:  
     - Удаление записи, на которую есть ссылки  
     - Создание "висящих" ссылок  

#### Правила обработки изменений:
CREATE TABLE order_items (
    item_id INT PRIMARY KEY,
    order_id INT REFERENCES orders(order_id)
        ON DELETE CASCADE  -- Удаляет связанные записи
        ON UPDATE SET NULL  -- При изменении order_id ставит NULL
);
#### Варианты действий при изменении PK:
- NO ACTION (по умолчанию) — запрет операции  
- CASCADE — каскадное обновление/удаление  
- SET NULL — установка NULL в FK  
- SET DEFAULT — установка значения по умолчанию  

---

### 10. Способы поддержания ссылочной целостности

#### 1. Ограничения FOREIGN KEY
ALTER TABLE employees 
ADD CONSTRAINT fk_department
FOREIGN KEY (dept_id) REFERENCES departments(id);
#### 2. Триггеры для сложных правил
CREATE TRIGGER check_salary
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    IF NEW.salary > (SELECT max_salary FROM departments WHERE id = NEW.dept_id) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Salary exceeds department limit';
    END IF;
END;
#### 3. Каскадные операции
-- Автоматическое удаление подчиненных записей
FOREIGN KEY (parent_id) REFERENCES parents(id) ON DELETE CASCADE
#### 4. Ограничения CHECK
-- Проверка диапазона значений
ALTER TABLE products ADD CHECK (price > 0);
#### 5. Транзакционные скрипты
// Псевдокод приложения
try {
    startTransaction();
    deleteDepartment(id);
    reassignEmployees(id);  -- Явная обработка связей
    commit();
} catch {
    rollback();
}
#### Сравнение методов:
| Метод               | Где работает         | Производительность | Гибкость |
|---------------------|----------------------|--------------------|----------|
| FOREIGN KEY         | Сервер БД            | Высокая            | Низкая   |
| Триггеры            | Сервер БД            | Средняя            | Высокая  |
| Проверки в коде     | Клиентское приложение| Низкая             | Максимальная |

---
### 11. Что такое реляционная алгебра?  
Реляционная алгебра — формальный язык операций для работы с таблицами (отношениями) в реляционных БД. Основывается на теории множеств и логике предикатов.  

#### Основные операции:  
1. Унарные (над одной таблицей):  
   - Выборка (σ)  
     σ(condition)(R) — фильтрация строк (аналог WHERE).  
     *Пример:* σ(salary > 50000)(Employees) → сотрудники с зарплатой >50k.  
   - Проекция (π)  
     π(attributes)(R) — выбор столбцов (аналог SELECT).  
     *Пример:* π(name, age)(Employees) → только имена и возраст.  

2. Бинарные (над двумя таблицами):  
   - Объединение (∪)  
     R ∪ S — строки из R или S (дубликаты удаляются).  
   - Разность (−)  
     R − S — строки из R, отсутствующие в S.  
   - Декартово произведение (×)  
     R × S — все комбинации строк R и S.  
   - Соединение (⋈)  
     R ⋈(condition) S — комбинация строк по условию (аналог JOIN).  

3. Специальные операции:  
   - Переименование (ρ)  
     ρ(new_name)(R) — смена имени таблицы/атрибута.  
   - Деление (÷)  
     Находит строки в R, связанные со всеми строками из S.  

#### Пример запроса в реляционной алгебре:  
-- SQL-аналог: SELECT name FROM Employees WHERE dept_id = 10;
π(name)(σ(dept_id = 10)(Employees))
 

#### Применение:  
- Теоретическая основа SQL.  
- Используется оптимизаторами запросов для построения планов выполнения.  

---

### 12. Примеры операций реляционной алгебры  
Рассмотрим таблицы:  
- Employees(id, name, dept_id, salary)  
- Departments(id, name, budget)  

1. Естественное соединение (⋈):  
   Employees ⋈ Departments → соединяет строки по совпадающим dept_id и id.  

2. Левое внешнее соединение (⟕):  
   Employees ⟕ Departments → все сотрудники + данные их отделов (если есть).  

3. Агрегация (γ):  
   γ(dept_id, AVG(salary))(Employees) → средняя зарплата по отделам.  

4. Выборка + проекция:  
   π(name)(σ(salary > 60000)(Employees)) → имена сотрудников с зарплатой >60k.  

5. Деление (÷):  
   Найти сотрудников, работающих во всех отделах с бюджетом >1M:  
   Employees ÷ π(id)(σ(budget > 1000000)(Departments)).  

---

### 13. Задачи проектирования БД  
Процесс включает 6 этапов:  

1. Сбор требований:  
   - Определение сущностей (клиенты, заказы).  
   - Бизнес-правила (например, «заказ должен иметь хотя бы 1 товар»).  

2. Концептуальное проектирование:  
   - Построение ER-диаграммы:   
     *Сущности:* Прямоугольники. *Связи:* Ромбы.  

3. Логическое проектирование:  
   - Преобразование ER-модели в схему таблиц.  
   - Пример:  
    
     CREATE TABLE Orders (
         order_id INT PRIMARY KEY,
         customer_id INT REFERENCES Customers(customer_id)
     );
     
4. Нормализация:  
   - Приведение к 3NF/BCNF для устранения аномалий.  
   - *Пример аномалии:* Повторение данных о клиенте в каждой записи заказа.  

5. Физическое проектирование:  
   - Выбор типов данных (VARCHAR vs TEXT).  
   - Создание индексов (CREATE INDEX idx_name ON Employees(name)).  
   - Партиционирование больших таблиц.  

6. Оптимизация:  
   - Денормализация для ускорения запросов (осознанное нарушение нормальных форм).  
   - Настройка кэширования.  

---
### 1. Что такое нормализация отношений?

Нормализация — процесс устранения избыточности данных путем декомпозиции таблиц согласно нормальным формам (НФ).

#### Основные нормальные формы:
1. 1NF (Первая НФ):
   - Все атрибуты атомарны (неделимы)
   - Нет повторяющихся групп
   - Пример нарушения:
    
     Orders(order_id, [product1, product2])  // Не атомарно
     
   - Исправление:
    
     OrderItems(order_id, product_id, quantity)
     
2. 2NF (Вторая НФ):
   - Соответствует 1NF
   - Нет частичных зависимостей от составного PK
   - Пример:
    
     OrderItems(order_id, product_id, product_name, ...)  // product_name зависит только от product_id
     
   - Исправление:
    
     Orders(order_id, ...)
     Products(product_id, product_name, ...)
     OrderItems(order_id, product_id, ...)
     
3. 3NF (Третья НФ):
   - Соответствует 2NF
   - Нет транзитивных зависимостей (неключевые атрибуты зависят только от PK)
   - Пример нарушения:
    
     Employees(emp_id, dept_id, dept_address)  // dept_address зависит от dept_id
     
   - Исправление:
    
     Employees(emp_id, dept_id)
     Departments(dept_id, dept_address)
     
4. BCNF (Бойса-Кодда):
   - Усиленная 3NF
   - Для каждой функциональной зависимости X → Y, X должен быть суперключом

#### Пример нормализации:
| Денормализованная таблица       | Нормализованные таблицы         |
|----------------------------------|----------------------------------|
| Orders(order_id, customer_name, product_name, price) | Orders(order_id, customer_id) |
|                                  | Customers(customer_id, name)  |
|                                  | Products(product_id, name, price) |
|                                  | OrderItems(order_id, product_id) |

Преимущества нормализации:
- Устранение аномалий (вставки, обновления, удаления)
- Минимизация дублирования данных
- Упрощение поддержки целостности

Недостатки:
- Усложнение запросов (необходимость JOIN)
- Возможное снижение производительности

---

### 2. Для чего предназначены индексы в СУБД?

Индексы — специальные структуры данных для ускорения поиска (аналог оглавления в книге).

#### Типы индексов:
1. B-деревья (наиболее распространены):
   - Поддерживают =, >, <, BETWEEN
   - Пример: CREATE INDEX idx_name ON users(last_name)

2. Хеш-индексы:
   - Точное совпадение (=)
   - Быстрее B-деревьев для простых равенств

3. Bitmap-индексы:
   - Для колонок с малым числом уникальных значений
   - Эффективны для DW

4. Полнотекстовые:
   - Поиск по словам в тексте
   - Поддержка морфологии

5. Пространственные:
   - Для GIS-данных (R-деревья)

#### Когда создавать индексы:
- Частые поисковые запросы
- JOIN, WHERE, ORDER BY колонки
- UNIQUE ограничения

#### Когда избегать:
- Частые массовые обновления
- Маленькие таблицы
- Колонки с малым количеством уникальных значений

Пример создания:
-- Составной индекс
CREATE INDEX idx_name_dep ON employees(last_name, department_id);

-- Уникальный индекс
CREATE UNIQUE INDEX idx_email ON users(email);
Затраты индексов:
- Дополнительное место на диске
- Замедление INSERT/UPDATE/DELETE
- Необходимость обслуживания (перестройка)

---

### 3. Назовите назначение журнализации изменений БД

Журнализация — запись всех изменений БД в специальный лог перед применением.

#### Основные функции:
1. Восстановление после сбоев:
   - Мягкий сбой (ОС/СУБД): повтор (REDO) зафиксированных транзакций
   - Жесткий сбой (диск): восстановление из резервной копии + применение журнала

2. Реализация транзакций:
   - Поддержка ACID
   - Механизм отката (UNDO)

3. Репликация:
   - Передача изменений на standby-серверы
   - MySQL binlog, PostgreSQL WAL

4. Аудит:
   - Трек изменений для соответствия требованиям (GDPR, SOX)

#### Типы журналов:
1. Журнал транзакций:
   - Фиксирует все изменения данных
   - Циклическая перезапись

2. Журнал отката:
   - Хранит "старые" значения для UNDO
   - Oracle Undo Tablespace

3. Бинарный журнал (MySQL):
   - Записывает изменения в виде SQL-операций
   - Используется для репликации

Пример работы:
1. UPDATE accounts SET balance = balance + 100 WHERE id = 1;
2. Запись в журнал: "[T1] account 1: balance was 500, now 600"
3. Фиксация в таблице
4. При сбое: анализ журнала и восстановление

---

### 4. Опишите процесс восстановления БД после мягкого сбоя

Мягкий сбой — аварийное завершение работы СУБД (без повреждения файлов данных).

#### Этапы восстановления:
1. Анализ журнала:
   - Определение незавершенных транзакций
   - Поиск последней контрольной точки (checkpoint)

2. Откат (UNDO):
   - Для незавершенных транзакций:
    
     -- Пример записи в журнале:
     -- [T1] UPDATE accounts SET balance = balance - 100 WHERE id = 1; (old value: 500)
     
     → Возврат balance к 500 для всех операций T1

3. Повтор (REDO):
   - Для зафиксированных транзакций:
    
     -- [T2] COMMIT; UPDATE accounts SET balance = balance + 200 WHERE id = 2;
     
     → Повторное выполнение изменений T2

4. Проверка целостности:
   - Валидация ограничений (FK, CHECK)
   - Восстановление индексов

Технические детали:
- В PostgreSQL: восстановление через WAL-файлы
- В Oracle: использование undo-сегментов
- В MySQL: анализ binlog + redo log

Время восстановления зависит от:
- Частоты контрольных точек
- Объема незавершенных транзакций
- Производительности диска

---

### 5. Опишите процесс восстановления БД после жесткого сбоя

Жесткий сбой — физическое повреждение файлов БД (диск, контроллер).

#### Этапы восстановления:
1. Восстановление из резервной копии:
   - Полная копия (full backup)
   - Инкрементальные/дифференциальные копии

2. Применение журналов:
   - Последовательное накатывание:
    
     full backup + incr1 + incr2 + ... + последний архивный журнал
     
3. Point-in-Time Recovery (PITR):
   - Восстановление на конкретный момент времени:
    
     -- PostgreSQL пример:
     RECOVER DATABASE UNTIL TIME '2024-03-20 15:00:00';
     
4. Восстановление индексов:
   - Перестроение поврежденных индексов
   - REINDEX TABLE accounts;

#### Стратегии резервирования:
1. Full + Transaction Log:
   - Еженедельно полный бэкап + ежедневно журналы

2. Дифференциальные бэкапы:
   - Полный бэкап + изменения с момента полного

3. Репликация:
   - Hot standby серверы

Пример для MySQL:
### Восстановление из mysqldump + binlog
mysql -u root -p db_name < full_backup.sql
mysqlbinlog --start-datetime="2024-03-20 00:00:00" binlog.000123 | mysql -u root -p
Критичные факторы:
- RTO (Recovery Time Objective)
- RPO (Recovery Point Objective)
- Проверка бэкапов (тестовые восстановления)

### 6. Что такое SELECT-запросы? Примеры

SELECT-запрос — оператор DML для выборки данных из таблиц БД. Основан на реляционной алгебре.

#### Базовый синтаксис:
SELECT [столбцы] 
FROM [таблицы] 
[WHERE условия] 
[GROUP BY группировка] 
[HAVING условия_групп] 
[ORDER BY сортировка] 
[LIMIT ограничение];
#### Примеры запросов:

1. Простая выборка:
  
   SELECT * FROM employees;
   
2. Фильтрация (WHERE):
  
   SELECT name, salary 
   FROM employees 
   WHERE department = 'IT' AND salary > 100000;
   
3. Сортировка (ORDER BY):
  
   SELECT product_name, price 
   FROM products 
   ORDER BY price DESC 
   LIMIT 10;
   
4. Группировка (GROUP BY):
  
   SELECT department, AVG(salary) as avg_salary
   FROM employees
   GROUP BY department
   HAVING AVG(salary) > 50000;
   
5. Соединение таблиц (JOIN):
  
   SELECT e.name, d.department_name
   FROM employees e
   JOIN departments d ON e.dept_id = d.id;
   
6. Подзапросы:
  
   SELECT name 
   FROM employees 
   WHERE salary > (SELECT AVG(salary) FROM employees);
   
#### Особенности в разных СУБД:
- MySQL: Поддержка LIMIT
- Oracle: Использование ROWNUM вместо LIMIT
- PostgreSQL: Расширенные оконные функции

---

### 7. Назовите оператор, используемый для группирования данных в SELECT-запросе

GROUP BY — оператор для группировки строк с одинаковыми значениями в указанных столбцах.

#### Синтаксис:
SELECT column1, aggregate_function(column2)
FROM table
GROUP BY column1;
#### Примеры использования:

1. Простая группировка:
  
   SELECT department, COUNT(*) as employee_count
   FROM employees
   GROUP BY department;
   
2. Группировка по нескольким полям:
  
   SELECT department, job_title, AVG(salary)
   FROM employees
   GROUP BY department, job_title;
   
3. Фильтрация групп (HAVING):
  
   SELECT department, AVG(salary)
   FROM employees
   GROUP BY department
   HAVING AVG(salary) > 50000;
   
#### Важные нюансы:
1. Все неагрегированные столбцы в SELECT должны быть в GROUP BY
2. Порядок выполнения: WHERE → GROUP BY → HAVING
3. Отличие HAVING от WHERE:
   - WHERE фильтрует строки до группировки
   - HAVING фильтрует группы после группировки

#### Агрегатные функции:
| Функция       | Описание                  |
|---------------|---------------------------|
| COUNT()       | Количество строк          |
| SUM()         | Сумма значений            |
| AVG()         | Среднее значение          |
| MIN()/MAX()   | Минимальное/максимальное  |
| GROUP_CONCAT()| Объединение строк (MySQL) |

---

### 8. Примеры команд манипулирования данными и примеры их использования

DML (Data Manipulation Language) — команды для работы с данными.

#### Основные команды:

1. INSERT — добавление данных:
  
   -- Вставка одной строки
   INSERT INTO employees (name, salary) 
   VALUES ('Иван Петров', 75000);

   -- Вставка нескольких строк
   INSERT INTO products (name, price)
   VALUES ('Ноутбук', 999.99), ('Телефон', 699.99);
   
2. UPDATE — изменение данных:
  
   -- Обновление всех строк
   UPDATE products 
   SET price = price * 1.1  -- Увеличить цены на 10%
   WHERE category = 'Электроника';

   -- Обновление с подзапросом
   UPDATE employees
   SET salary = salary * 1.05
   WHERE department IN (SELECT id FROM departments WHERE budget > 1000000);
   
3. DELETE — удаление данных:
  
   -- Удаление по условию
   DELETE FROM orders 
   WHERE order_date < '2023-01-01';

   -- Каскадное удаление
   DELETE FROM customers 
   WHERE id = 123;  -- Если есть ON DELETE CASCADE
   
4. MERGE (UPSERT) — объединение операций:
  
   -- PostgreSQL пример
   INSERT INTO inventory (product_id, quantity)
   VALUES (123, 10)
   ON CONFLICT (product_id) 
   DO UPDATE SET quantity = inventory.quantity + 10;

Anatoliy Dobrynin, [08.06.2025 12:12]
#### Транзакционный пример:
BEGIN;
  INSERT INTO orders (customer_id, amount) 
  VALUES (456, 199.99);
  
  UPDATE inventory 
  SET stock = stock - 1 
  WHERE product_id = 789;
COMMIT;
---

### 9. Назначение анализаторов с INSERT, DELETE, UPDATE

Анализаторы — компоненты СУБД, проверяющие корректность DML-операций перед выполнением.

#### Этапы анализа:

1. Лексический анализ:
   - Разбор SQL-токенов
   - Проверка ключевых слов

2. Синтаксический анализ:
   - Построение синтаксического дерева
   - Проверка структуры запроса

3. Семантический анализ:
   - Проверка существования таблиц/столбцов
   - Соответствие типов данных
   - Проверка ограничений (NOT NULL, UNIQUE)

4. Оптимизация:
   - Выбор плана выполнения
   - Для UPDATE/DELETE — оценка количества затрагиваемых строк

#### Примеры проверок:
- INSERT:
 
  INSERT INTO employees (name, salary) 
  VALUES (NULL, 'не число');  -- Ошибка: нарушение NOT NULL и типа данных
  
- UPDATE:
 
  UPDATE products 
  SET price = -100  -- Ошибка: CHECK (price > 0)
  WHERE id = 123;
  
- DELETE:
 
  DELETE FROM departments 
  WHERE id = 10;  -- Ошибка: FOREIGN KEY violation
  
#### Особенности в разных СУБД:
- MySQL: Strict mode для строгой проверки типов
- Oracle: Проверка ограничений на уровне транзакции
- PostgreSQL: Расширенная проверка типов (ENUM, домены)

---

### 10. Опишите архитектуру "клиент-сервер"

Клиент-серверная архитектура — модель взаимодействия, где:
- Сервер БД хранит и обрабатывает данные
- Клиент отправляет запросы и отображает результаты

#### Компоненты сервера:
1. Процессор запросов:
   - Парсинг SQL
   - Оптимизация
   - Генерация плана выполнения

2. Менеджер транзакций:
   - Управление блокировками
   - Контроль изоляции

3. Менеджер хранения:
   - Работа с файлами данных
   - Управление буферами

4. Журнализация:
   - WAL (Write-Ahead Logging)
   - Контрольные точки

#### Компоненты клиента:
1. Интерфейс пользователя:
   - GUI (DBeaver, pgAdmin)
   - Командная строка (psql, mysql)

2. Драйверы подключения:
   - ODBC/JDBC
   - Специфичные протоколы (MongoDB Wire)

3. Пулы соединений:
   - Управление подключениями
   - Кэширование запросов

#### Пример взаимодействия:
1. Клиент устанавливает соединение (аутентификация)
2. Отправка SQL-запроса:
  
   SELECT * FROM products WHERE price > 100;
   
3. Сервер:
   - Проверяет права
   - Оптимизирует запрос
   - Выполняет поиск
   - Возвращает результат
4. Клиент отображает данные

#### Преимущества:
- Централизованное управление данными
- Безопасность (данные на сервере)
- Масштабируемость

#### Современные вариации:
- Трехзвенная архитектура: Клиент → Сервер приложений → Сервер БД
- Облачные СУБД: AWS RDS, Google Cloud SQL
- Микросервисы: Каждая служба со своей БД

### 11. Объясните взаимодействие между клиентским приложением и сервером

Механизм взаимодействия клиента и сервера БД включает несколько ключевых этапов:

#### 1. Установка соединения
- Протоколы подключения:
  - TCP/IP (стандартный порт MySQL: 3306, PostgreSQL: 5432)
  - Named Pipes (для локальных соединений в Windows)
  - Unix-domain sockets (Linux/Unix)
- Аутентификация:
  - Проверка логина/пароля
  - Сертификаты SSL/TLS
  - Интеграция с LDAP/Kerberos

*Пример (PostgreSQL):*
### Python с psycopg2
conn = psycopg2.connect(
    host="localhost",
    port=5432,
    dbname="mydb",
    user="admin",
    password="secret"
)
#### 2. Выполнение запроса
1. Клиент отправляет SQL-запрос:
  
   SELECT product_name, price FROM products WHERE category = 'Electronics';
   
2. Сервер:
   - Парсинг → проверка синтаксиса
   - Оптимизация → выбор плана выполнения (использование индексов)
   - Исполнение → чтение данных
3. Возврат результата в виде:
   - Таблицы (результирующий набор)
   - Статуса выполнения (успех/ошибка)

#### 3. Управление транзакциями
- Клиент контролирует:
 
  BEGIN;  -- Старт транзакции
  INSERT INTO orders (...) VALUES (...);
  COMMIT; -- Фиксация или ROLLBACK при ошибке
  
#### 4. Завершение работы
- Закрытие соединения:
 
  conn.close()  -- Освобождение ресурсов
  
Протоколы передачи данных:
| Протокол       | Использование               | Пример СУБД         |
|----------------|-----------------------------|---------------------|
| Tabular Data Stream (TDS) | Microsoft SQL Server | Sybase |
| PostgreSQL Protocol | Специфичен для PostgreSQL | PgBouncer |
| MySQL Protocol | Оптимизирован для MySQL | ProxySQL |

---

### 12. Функции, которые выполняет клиент и сервер

#### Функции клиента:
1. Формирование запросов:
   - Генерация SQL
   - Параметризованные запросы
  
   // Java JDBC пример
   PreparedStatement stmt = conn.prepareStatement(
       "SELECT * FROM users WHERE age > ?");
   stmt.setInt(1, 18);
   
2. Отображение данных:
   - Преобразование результатов в таблицы/графики
   - Пагинация (LIMIT/OFFSET)

3. Управление соединениями:
   - Пулы соединений (HikariCP, c3p0)
   - Повторное подключение при обрыве

4. Кэширование:
   - Локальное кэширование результатов
   - ORM-кэш (Hibernate, Django ORM)

#### Функции сервера:
1. Обработка запросов:
   - Парсинг и оптимизация SQL
   - Использование индексов
   - Параллельное выполнение

2. Управление транзакциями:
   - Блокировки (row-level, table-level)
   - Управление изоляцией (READ COMMITTED, SERIALIZABLE)

3. Безопасность:
   - Проверка прав (GRANT/REVOKE)
   - Шифрование данных

4. Хранение данных:
   - Управление табличными пространствами
   - Сжатие данных
   - Репликация

Распределение нагрузки:
| Задача               | Клиентская часть           | Серверная часть       |
|----------------------|----------------------------|-----------------------|
| Валидация данных     | Проверка форматов          | CHECK-ограничения     |
| Сортировка           | Простые сортировки         | ORDER BY с индексами  |
| Агрегация            | Фильтрация результатов     | GROUP BY с хэшированием |

---

### 13. Что такое триггер в БД? Для чего он применяется?

Триггер — автоматически выполняемый код при наступлении события DML (INSERT/UPDATE/DELETE).

#### Типы триггеров:
1. По времени:
   - BEFORE — проверка данных перед изменением
   - AFTER — логирование после изменения
   - INSTEAD OF — для представлений (VIEW)

2. По событию:
   - ROW-level — для каждой строки
   - STATEMENT-level — один раз для оператора

#### Примеры использования:
1. Аудит изменений:
  
   CREATE TRIGGER log_employee_changes
   AFTER UPDATE ON employees
   FOR EACH ROW
   INSERT INTO audit_log VALUES (
       CURRENT_TIMESTAMP, 
       'employees', 
       OLD.salary, NEW.salary
   );

2. Каскадные обновления:
  
   CREATE TRIGGER update_inventory
   AFTER INSERT ON orders
   FOR EACH ROW
   UPDATE products 
   SET stock = stock - NEW.quantity
   WHERE id = NEW.product_id;
   
3. Сложная валидация:
  
   CREATE TRIGGER validate_salary
   BEFORE INSERT ON employees
   FOR EACH ROW
   BEGIN
       IF NEW.salary < (SELECT min_salary FROM departments WHERE id = NEW.dept_id) THEN
           SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Salary too low';
       END IF;
   END;
   
#### Плюсы и минусы:
| Преимущества                  | Недостатки                     |
|-------------------------------|--------------------------------|
| Централизация бизнес-логики   | Сложность отладки              |
| Гарантия выполнения правил    | Скрытое поведение системы      |
| Автоматизация сложных операций | Влияние на производительность |

Поддержка в СУБД:
- PostgreSQL: Триггеры на PL/pgSQL
- Oracle: PL/SQL триггеры с расширенными возможностями
- MySQL: Ограниченная функциональность (нет DDL-триггеров)

---

### 14. Что такое хранимая процедура? Отличие от триггера

Хранимая процедура — предкомпилированный код SQL, хранящийся на сервере и вызываемый явно.

#### Сравнение с триггерами:
| Характеристика       | Хранимая процедура           | Триггер                |
|----------------------|------------------------------|------------------------|
| Вызов            | Явный (CALL proc_name())     | Автоматический         |
| Возврат значений | Да (OUT-параметры, курсоры)  | Нет                    |
| Транзакции       | Может управлять (COMMIT/ROLLBACK) | Нет             |
| Использование    | Сложная бизнес-логика        | Реакция на изменения данных |

#### Пример процедуры (MySQL):
DELIMITER //
CREATE PROCEDURE transfer_funds(
    IN from_account INT,
    IN to_account INT,
    IN amount DECIMAL(10,2),
    OUT status VARCHAR(100)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET status = 'Error: ' + SQL_ERROR;
    END;
    
    START TRANSACTION;
        UPDATE accounts SET balance = balance - amount WHERE id = from_account;
        UPDATE accounts SET balance = balance + amount WHERE id = to_account;
        INSERT INTO transactions VALUES (from_account, to_account, amount, NOW());
        SET status = 'Success';
    COMMIT;
END //
DELIMITER ;

-- Вызов
CALL transfer_funds(123, 456, 500.00, @result);
#### Применение процедур:
1. Сложные транзакции (банковские переводы)
2. Пакетная обработка (ежедневные отчеты)
3. API для приложений (инкапсуляция логики)

---

### 15. Что такое представление (VIEW)? Примеры использования

Представление — виртуальная таблица, определяемая запросом SQL.

#### Типы представлений:
1. Простые VIEW:
   - Основаны на одном SELECT
   - Пример:
    
     CREATE VIEW active_customers AS
     SELECT * FROM customers WHERE last_purchase_date > CURRENT_DATE - INTERVAL '1 year';
     
2. Материализованные VIEW:
   - Физическое хранение данных (Oracle, PostgreSQL)
   - Периодическое обновление
  
   CREATE MATERIALIZED VIEW monthly_sales AS
   SELECT product_id, SUM(amount) 
   FROM sales 
   GROUP BY product_id
   WITH DATA;
   
3. Рекурсивные VIEW (иерархические данные):
  
   WITH RECURSIVE employee_tree AS (
       SELECT id, name, manager_id FROM employees WHERE id = 100
       UNION ALL
       SELECT e.id, e.name, e.manager_id 
       FROM employees e
       JOIN employee_tree et ON e.manager_id = et.id
   )
   SELECT * FROM employee_tree;
   
#### Преимущества:
- Безопасность: Ограничение доступа к столбцам
 
  CREATE VIEW public_employee_data AS
  SELECT id, name, department FROM employees;  -- Без salary
  
- Упрощение запросов:
 
  -- Вместо сложного JOIN:
  SELECT * FROM order_details_view WHERE customer_id = 123;
  
- Совместимость: Эмуляция измененной схемы таблиц

Ограничения:
- Некоторые VIEW не обновляемы (с GROUP BY, DISTINCT)
- Производительность сложных VIEW может быть низкой